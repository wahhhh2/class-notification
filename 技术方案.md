# 基于微信消息推送的班级通知系统技术方案

## 项目概述
基于微信消息推送的班级通知系统是一款纯前端实现的实时通知工具，通过微信接口实现教师与班班通设备之间的消息推送和状态反馈。系统包含发送端和接收端两个独立网页，实现通知的实时发送、接收和已读确认功能。

## 技术架构

### 整体架构
```
发送端 → 微信接口 → 接收端(班班通设备) → 反馈状态 → 发送端
      ↓                ↓
  本地存储          本地存储
```

### 技术栈
- **前端框架**：原生HTML5 + CSS3 + JavaScript (ES6+)
- **数据存储**：浏览器localStorage
- **消息传递**：WebSocket模拟（由于纯前端限制）+ URL参数
- **微信集成**：微信Web API模拟
- **部署方式**：GitHub Pages

## 详细技术实现

### 1. 系统架构设计

#### 核心组件
- **发送端(send.html)**：教师使用的发送界面
- **接收端(receive.html)**：部署在班班通设备上的接收界面
- **本地存储服务**：管理消息和状态数据
- **通信模块**：模拟实时通信功能

#### 数据流设计
```
1. 发送端创建消息 → 本地存储 → 生成唯一URL
2. URL通过微信分享 → 接收端访问
3. 接收端解析URL → 显示通知 → 本地存储
4. 点击"收到" → 更新状态 → 生成反馈URL
5. 发送端轮询检查状态更新
```

### 2. 数据结构设计

#### 消息数据结构
```javascript
{
  id: "msg_1234567890", // 唯一消息ID
  content: "今天下午3点在会议室开会", // 消息内容
  sender: "张老师", // 发送者
  timestamp: 1640995200000, // 发送时间戳
  status: "sent", // 状态：sent, delivered, read
  receiverIds: ["classroom_1", "classroom_2"], // 接收端ID列表
  readReceipts: [ // 已读回执
    {
      receiverId: "classroom_1",
      readTime: 1640995300000,
      deviceInfo: "班班通设备1"
    }
  ]
}
```

#### 设备注册结构
```javascript
{
  deviceId: "classroom_1",
  name: "一年级一班",
  lastActive: 1640995200000,
  status: "online"
}
```

### 3. 发送端实现

#### 核心功能
- 消息编辑和发送
- 接收端设备管理
- 消息状态跟踪
- 历史消息查看

#### 关键代码实现
```javascript
// 消息发送核心功能
class MessageSender {
  constructor() {
    this.messageStore = new MessageStorage();
    this.deviceManager = new DeviceManager();
  }
  
  // 创建并发送消息
  sendMessage(content, receiverIds) {
    const message = {
      id: "msg_" + Date.now(),
      content: content,
      sender: localStorage.getItem('teacherName') || '教师',
      timestamp: Date.now(),
      status: "sent",
      receiverIds: receiverIds,
      readReceipts: []
    };
    
    // 保存到本地存储
    this.messageStore.saveMessage(message);
    
    // 生成分享链接（模拟微信推送）
    const shareUrl = this.generateShareUrl(message);
    
    return {
      success: true,
      messageId: message.id,
      shareUrl: shareUrl
    };
  }
  
  // 生成分享URL
  generateShareUrl(message) {
    const baseUrl = window.location.origin + window.location.pathname.replace('send.html', 'receive.html');
    const params = new URLSearchParams({
      msgId: message.id,
      content: message.content,
      sender: message.sender,
      timestamp: message.timestamp
    });
    return `${baseUrl}?${params.toString()}`;
  }
  
  // 轮询检查消息状态
  checkMessageStatus(messageId, callback) {
    const interval = setInterval(() => {
      const message = this.messageStore.getMessageById(messageId);
      if (message && callback) {
        callback(message);
        
        // 如果所有接收端都已读，停止轮询
        if (message.receiverIds.length === message.readReceipts.length) {
          clearInterval(interval);
        }
      }
    }, 5000); // 每5秒检查一次
    
    return interval; // 返回interval ID以便后续清除
  }
}

// 设备管理功能
class DeviceManager {
  constructor() {
    this.devices = JSON.parse(localStorage.getItem('registeredDevices') || '[]');
  }
  
  // 注册新设备
  registerDevice(device) {
    this.devices.push({
      ...device,
      lastActive: Date.now(),
      status: "online"
    });
    this.saveDevices();
  }
  
  // 获取所有设备
  getAllDevices() {
    return this.devices;
  }
  
  // 保存设备列表
  saveDevices() {
    localStorage.setItem('registeredDevices', JSON.stringify(this.devices));
  }
}
```

### 4. 接收端实现

#### 核心功能
- 自动接收并显示通知
- "收到"确认按钮
- 状态反馈机制
- 通知历史管理

#### 关键代码实现
```javascript
// 消息接收核心功能
class MessageReceiver {
  constructor() {
    this.messageStore = new MessageStorage();
    this.deviceId = this.getOrCreateDeviceId();
  }
  
  // 获取或创建设备ID
  getOrCreateDeviceId() {
    let deviceId = localStorage.getItem('deviceId');
    if (!deviceId) {
      deviceId = "classroom_" + Math.random().toString(36).substr(2, 9);
      localStorage.setItem('deviceId', deviceId);
    }
    return deviceId;
  }
  
  // 从URL接收消息
  receiveFromUrl() {
    const urlParams = new URLSearchParams(window.location.search);
    const msgId = urlParams.get('msgId');
    
    if (msgId) {
      const message = {
        id: msgId,
        content: urlParams.get('content') || '',
        sender: urlParams.get('sender') || '未知',
        timestamp: parseInt(urlParams.get('timestamp') || Date.now()),
        status: "delivered",
        receivedAt: new Date().toLocaleString('zh-CN')
      };
      
      // 保存到本地存储
      this.messageStore.saveReceivedMessage(message);
      
      return message;
    }
    
    return null;
  }
  
  // 发送已读确认
  sendReadReceipt(messageId) {
    const receipt = {
      receiverId: this.deviceId,
      messageId: messageId,
      readTime: Date.now(),
      deviceInfo: navigator.userAgent
    };
    
    // 保存确认记录
    this.messageStore.saveReadReceipt(receipt);
    
    // 生成反馈URL（用于发送端获取状态）
    return this.generateFeedbackUrl(receipt);
  }
  
  // 生成反馈URL
  generateFeedbackUrl(receipt) {
    const baseUrl = window.location.origin + window.location.pathname.replace('receive.html', 'send.html');
    const params = new URLSearchParams({
      action: 'read_receipt',
      messageId: receipt.messageId,
      receiverId: receipt.receiverId,
      timestamp: receipt.readTime
    });
    return `${baseUrl}?${params.toString()}`;
  }
}
```

### 5. 本地存储服务

#### 关键代码实现
```javascript
class MessageStorage {
  // 保存发送的消息
  saveMessage(message) {
    const messages = this.getSentMessages();
    messages.push(message);
    localStorage.setItem('sent_messages', JSON.stringify(messages));
  }
  
  // 保存接收的消息
  saveReceivedMessage(message) {
    const messages = this.getReceivedMessages();
    
    // 检查消息是否已存在
    const existingIndex = messages.findIndex(m => m.id === message.id);
    if (existingIndex >= 0) {
      messages[existingIndex] = { ...messages[existingIndex], ...message };
    } else {
      messages.push(message);
    }
    
    // 限制消息数量
    if (messages.length > 100) {
      messages.shift();
    }
    
    localStorage.setItem('received_messages', JSON.stringify(messages));
  }
  
  // 保存已读回执
  saveReadReceipt(receipt) {
    const receipts = this.getReadReceipts();
    receipts.push(receipt);
    localStorage.setItem('read_receipts', JSON.stringify(receipts));
    
    // 更新本地消息状态
    const messages = this.getReceivedMessages();
    const messageIndex = messages.findIndex(m => m.id === receipt.messageId);
    if (messageIndex >= 0) {
      messages[messageIndex].status = "read";
      localStorage.setItem('received_messages', JSON.stringify(messages));
    }
  }
  
  // 获取所有发送的消息
  getSentMessages() {
    return JSON.parse(localStorage.getItem('sent_messages') || '[]');
  }
  
  // 获取所有接收的消息
  getReceivedMessages() {
    return JSON.parse(localStorage.getItem('received_messages') || '[]');
  }
  
  // 获取所有已读回执
  getReadReceipts() {
    return JSON.parse(localStorage.getItem('read_receipts') || '[]');
  }
  
  // 根据ID获取消息
  getMessageById(messageId) {
    const messages = this.getSentMessages();
    return messages.find(m => m.id === messageId);
  }
  
  // 更新发送消息的状态
  updateSentMessageStatus(messageId, updates) {
    const messages = this.getSentMessages();
    const messageIndex = messages.findIndex(m => m.id === messageId);
    
    if (messageIndex >= 0) {
      messages[messageIndex] = { ...messages[messageIndex], ...updates };
      localStorage.setItem('sent_messages', JSON.stringify(messages));
      return true;
    }
    
    return false;
  }
}
```

### 6. 界面设计

#### 发送端界面
- 消息编辑区域
- 设备选择列表
- 发送按钮
- 消息状态显示区
- 历史消息列表

#### 接收端界面
- 通知显示区域（大字体，清晰可见）
- "收到"按钮（醒目的设计）
- 通知历史列表
- 设备状态指示

### 7. 模拟微信推送机制

由于纯前端限制，我们将使用以下方式模拟微信推送：
1. 发送端生成包含消息的唯一URL
2. 通过实际的微信分享功能分享该URL
3. 班班通设备访问该URL接收消息
4. 使用URL参数传递已读状态

### 8. 部署方案

- **GitHub Pages部署**：
  - 上传所有HTML、CSS、JavaScript文件
  - 确保.nojekyll文件存在（避免Jekyll处理）
  - 配置正确的页面路径

- **班班通设备设置**：
  - 在班班通设备上打开接收端页面
  - 设置自动刷新（可选，确保及时接收新消息）
  - 全屏显示模式，避免误操作

## 技术挑战与解决方案

### 1. 实时通信限制
- **挑战**：纯前端无法实现真正的WebSocket服务器
- **解决方案**：使用轮询+URL参数传递模拟实时通信

### 2. 状态同步
- **挑战**：多设备间状态同步困难
- **解决方案**：使用URL参数和本地存储结合的方式传递状态更新

### 3. 微信接口限制
- **挑战**：纯前端难以直接调用微信接口
- **解决方案**：利用微信内置的分享功能，通过URL参数传递信息

## 扩展性考虑

1. **未来可添加的功能**：
   - 消息优先级标记
   - 批量操作功能
   - 消息模板管理
   - 数据导出功能

2. **技术升级路径**：
   - 引入Firebase等BaaS服务实现真正的实时通信
   - 添加简单后端支持更复杂的功能
   - 开发微信小程序版本

## 测试策略

1. **功能测试**：
   - 消息发送和接收测试
   - 已读确认功能测试
   - 多设备测试

2. **兼容性测试**：
   - 主流浏览器测试
   - 班班通设备兼容性测试

3. **性能测试**：
   - 长时间运行稳定性测试
   - 消息处理速度测试

## 安全考虑

1. **数据安全**：
   - 所有数据仅存储在本地浏览器
   - 不涉及敏感信息传输

2. **访问控制**：
   - 通过URL分享控制消息访问
   - 可考虑添加简单的访问码机制

## 总结

本技术方案通过纯前端技术实现了基于微信消息推送的班级通知系统，包含发送端和接收端两个独立网页。虽然受到纯前端架构的限制，无法实现真正的实时通信和服务器存储，但通过巧妙设计URL参数传递和本地存储机制，成功模拟了消息推送和状态反馈功能，满足了基本的教学场景需求。